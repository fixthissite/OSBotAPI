{"name":"Lemons OSBot API","tagline":"\"lemons\" API","body":"##wtf is this?\r\nThis is my personal \"API\", or extension of OSBot's normal API (as a note I use Framework/API interchangeably in this document.) It has a few extra features, namely:\r\n\r\n- Web Walker\r\n- Advanced Interactions (wip)\r\n- Encourages reusable, configurable code\r\n- Helper functions to make life easier\r\n- No more filters, just Lambda goodness!\r\n- Probably some stuff I forgot about (lol)\r\n\r\n##Before you get going...\r\nIf you are planning on using the \"lemons\" API, great! Make sure to report bugs ASAP, I will work on a fix right away! Contact me at:\r\n\r\nSkype: admin@gfxtub.com\r\nSteam: dudeami\r\n\r\nFeel free to ask me anything you want, anytime, for any reason. If I don't answer, its probably because I don't sit at the computer all day :p I'll get with you ASAP though!\r\n\r\nPlease leave some info so I know why I want to add you, thanks!\r\n\r\n##Documentation\r\n[Go to documentation](https://github.com/Lem0ns/OSBotAPI/wiki)\r\n\r\n##Quick overview of \"Tasks\"\r\nProbably the single biggest difference in scripts is the \"Task\" system. Basically, instead of one large Script that contains a bunch of if statements/states/etc, we split it up like a \"node\" system into seperate classes. The improvement the Tasks have is they have access to the OSBot API and lemons API just like a normal Script would.\r\n\r\n###Making a simple Task\r\nSo, lets say you want to make a simple task. Lets get real generic and say were chopping down a Tree. So, we make a new `AbstractTask` \"ChopTreeTask\":\r\n\r\n```java\r\nimport lemons.api.script.entities.RS2Object;\r\nimport lemons.api.tasks.templates.AbstractTask;\r\n\r\npublic class ChopDownTreeTask extends AbstractTask {\r\n\r\n\tprivate String[] names;\r\n\r\n\tpublic ChopDownTreeTask(String... treeTypes) {\r\n\t\t// OSBot and lemons API is not available\r\n\t\tnames = treeTypes;\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic void onStart() {\r\n\t\tsuper.onStart();\r\n\t\t\r\n\t\t// Ran when the Task is added, used to initialize the script\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic void onTaskStart() {\r\n\t\t// Task is now active, init if needed\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic void onTaskFinish() {\r\n\t\t// Task is no longer active, clean up\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic void run() {\r\n\t\t// Equal to \"onLoop\" but with no return\r\n\t\tif (getTree().interact(\"Chop down\")) {\r\n\t\t\tsleepMoving(5000);\r\n\t\t\tsleep(2000, () -> !myPlayer().isAnimating());\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic boolean isActive() {\r\n\t\t// Checks if the task can be ran\r\n\t\treturn !getInventory().isFull()\r\n\t\t\t\t&& getTree() != null\r\n\t\t\t\t&& !myPlayer().isAnimating();\r\n\t}\r\n\t\r\n\tpublic RS2Object getTree() {\r\n\t\t// Note the EntityAPI here is different, this is to add\r\n\t\t// additional helpers to the object and to replace lost\r\n\t\t// functionality from filters.\r\n\t\treturn getObjects().closest(o -> o.hasName(names));\r\n\t}\r\n\r\n}\r\n```\r\n\r\n###Building the Script\r\nBut, that is only one part of the puzzle right? Well, that is the point. Now, wherever you need to chop down a tree, you can simply add that Task. Lets say we want to take that `ChopTreeTask`, and make it into a power cutter. Simple, we just make a \"Controller\" (either a `ComplexTask` or ultimately a `TaskScript`) to run it. So, we'll make a new `TaskScript` for this example:\r\n\r\n```java\r\nimport org.osbot.rs07.api.ui.Skill;\r\n\r\nimport lemons.api.script.TaskScript;\r\n\r\npublic class TreeChopper extends TaskScript {\r\n\r\n\t@Override\r\n\tpublic void onStart() {\r\n\t\tsuper.onStart();\r\n\t\t\r\n\t\t// Set the tasks in the order you want them executed\r\n\t\t\r\n\t\t// We want to drop logs, luckily the API already contains this task\r\n\t\t// Feel free to make your own though!\r\n\t\taddTask(new DropperTask()\r\n\t\t\t.drop(\"Logs\", \"Oak logs\", \"Willow logs\"));\r\n\t\t\r\n\t\t// Lets add willow tree chopping\r\n\t\taddTask(() -> lvl() >= 30, new ChopDownTreeTask(\"Willow tree\"));\r\n\t\t// The lambda confuse you? Heres a more syntax'ed version\r\n\t\taddTask(() -> {\r\n\t\t\treturn lvl() >= 15;\r\n\t\t}, new ChopDownTreeTask(\"Oak tree\"));\r\n\t\t// For more info, google \"Java Lambda\"\r\n\t\taddTask(new ChopDownTreeTask(\"Tree\"));\r\n\t}\r\n\t\r\n\tprivate int lvl() {\r\n\t\treturn getSkills().getStatic(Skill.WOODCUTTING);\r\n\t}\r\n\t\r\n}\r\n```\r\n\r\nNow, we have a script that could run (it is missing a `ScriptManifest` though!). So, wheres the loop? Well, remember we moved all the \"Script\" stuff to the Task system, specifically `AbstractTask`. So, `TaskScript.addTask` simply adds a new Task to the queue. The queue is then ran in order every loop, top to bottom. This will behave similar to a script that checks states at the start of every loop, or the dreaded `if {} else ...` stack. This example also laminates how setting up parameters can make the Task reusable for multiple purposes, though this is a fairly simple example.\r\n\r\n###Adding a little lemon\r\nSo, you can chop wood and drop it, but we want more. So, lets put the API to use and add equipment handling, banking, and walking back to the area.\r\n\r\n```java\r\nimport org.osbot.rs07.api.map.Position;\r\nimport org.osbot.rs07.api.ui.EquipmentSlot;\r\nimport org.osbot.rs07.api.ui.Skill;\r\n\r\nimport lemons.api.script.TaskScript;\r\nimport lemons.api.tasks.DropperTask;\r\nimport lemons.api.tasks.WalkingTask;\r\nimport lemons.api.tasks.banking.EquipmentReq;\r\nimport lemons.api.tasks.banking.EquipmentReqTask;\r\nimport lemons.api.walking.map.Zone;\r\n\r\n\r\npublic class TreeChopper extends TaskScript {\r\n\r\n\t@Override\r\n\tpublic void onStart() {\r\n\t\tsuper.onStart();\r\n\t\t\r\n\t\t// Lets add our EquipmentReqTask, which also removes the need\r\n\t\t// (most of the time) for a BankTask. This also have all the\r\n\t\t// API of a regular BankTask.\r\n\t\t// Note the BankTask by default deposits everything, and the\r\n\t\t// EquipmentReqTask won't deposit the equipment it needs at\r\n\t\t// that time.\r\n\t\taddTask(new EquipmentReqTask()\r\n\t\t\t\t// Axe goes in the WEAPON slot, and setup the EquipmentReq\r\n\t\t\t\t.addReq(EquipmentSlot.WEAPON, new EquipmentReq(true, false)\r\n\t\t\t\t\t// Lets add the Dragon axe\r\n\t\t\t\t\t.addItem(\"Dragon axe\")\r\n\t\t\t\t\t\t// We can use it for woodcutting at lvl 60\r\n\t\t\t\t\t\t.setUseLevel(Skill.WOODCUTTING, 60)\r\n\t\t\t\t\t\t// We can equip it if we have 60 attack\r\n\t\t\t\t\t\t.setEquipLevel(Skill.ATTACK, 60)\r\n\t\t\t\t\t// And repeat for the rest\r\n\t\t\t\t\t.addItem(\"Rune axe\")\r\n\t\t\t\t\t\t.setUseLevel(Skill.WOODCUTTING, 41)\r\n\t\t\t\t\t\t.setEquipLevel(Skill.ATTACK, 40)\r\n\t\t\t\t\t.addItem(\"Adamant axe\")\r\n\t\t\t\t\t\t.setUseLevel(Skill.WOODCUTTING, 31)\r\n\t\t\t\t\t\t.setEquipLevel(Skill.ATTACK, 30)\r\n\t\t\t\t\t.addItem(\"Mithril axe\")\r\n\t\t\t\t\t\t.setUseLevel(Skill.WOODCUTTING, 21)\r\n\t\t\t\t\t\t.setEquipLevel(Skill.ATTACK, 20)\r\n\t\t\t\t\t.addItem(\"Black axe\")\r\n\t\t\t\t\t\t.setUseLevel(Skill.WOODCUTTING, 11)\r\n\t\t\t\t\t\t.setEquipLevel(Skill.ATTACK, 10)\r\n\t\t\t\t\t.addItem(\"Steel axe\")\r\n\t\t\t\t\t\t.setUseLevel(Skill.WOODCUTTING, 6)\r\n\t\t\t\t\t\t.setEquipLevel(Skill.ATTACK, 5)\r\n\t\t\t\t\t.addItem(\"Iron axe\")\r\n\t\t\t\t\t\t.setUseLevel(Skill.WOODCUTTING, 1)\r\n\t\t\t\t\t\t.setEquipLevel(Skill.ATTACK, 1)\r\n\t\t\t\t\t.addItem(\"Bronze axe\")\r\n\t\t\t\t\t\t.setUseLevel(Skill.WOODCUTTING, 1)\r\n\t\t\t\t\t\t.setEquipLevel(Skill.ATTACK, 1)\r\n\t\t));\r\n\t\t\r\n\t\t// Lets walk to the zone, note that the positions are fake!\r\n\t\t// Set to draynor or something, or better yet ask the user.\r\n\t\taddTask(new WalkingTask(\r\n\t\t\t\tnew Zone(this)\r\n\t\t\t\t\t.rect(new Position(1234, 1234, 0), new Position(1234, 1234, 0))));\r\n\t\t\r\n\t\t// Add a couple tree chop tasks\r\n\t\taddTask(() -> lvl() >= 15, new ChopDownTreeTask(\"Oak tree\"));\r\n\t\taddTask(new ChopDownTreeTask(\"Tree\"));\r\n\t}\r\n\t\r\n\tprivate int lvl() {\r\n\t\treturn getSkills().getStatic(Skill.WOODCUTTING);\r\n\t}\r\n\t\r\n}\r\n\r\n```\r\n\r\nSee how easy that was? That is the power of code re-usability with the Task system. No need to re-write code. Things like banking and equipment handling are now as simple as passing some configuration to an existing Task. As such, if some bug is exposed or code needs updating, its much simpler since the code is only written once, saving time on maintaining your Scripts.\r\n\r\n##How do I get started?\r\nJust clone the git into the \"lemons/api\" folder in your projects \"src\" folder.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}